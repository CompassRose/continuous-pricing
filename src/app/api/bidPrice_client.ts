//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming


import { map, mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf, BehaviorSubject } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';


export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');


// Fallback in case of null url
export const BASE_LOCALHOST_5000 = "http://localhost:5000";

@Injectable()
export class AccountClient {
    private http: HttpClient;
    private baseUrl: any;

    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : BASE_LOCALHOST_5000;
    }


    login(login: Login): Observable<LoginResponse> {
        let url_ = this.baseUrl + "/Account/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(login);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoginResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoginResponse>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<LoginResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result401: any = null;
                let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;

                return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = LoginResponse.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoginResponse>(null as any);
    }
}


@Injectable()
export class AirlineConfigClient {
    private http: HttpClient;
    private baseUrl: string;

    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {

        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : BASE_LOCALHOST_5000;
        console.log('AirlineConfigClient this.baseUrl ', this.baseUrl)
    }

    /**
     * @return Success.
     */
    get(): Observable<AirlineConfig> {
        let url_ = this.baseUrl + "/AirlineConfig";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AirlineConfig>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AirlineConfig>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<AirlineConfig> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = AirlineConfig.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AirlineConfig>(null as any);
    }
}

@Injectable()
export class BidPriceInfluencesClient {
    private http: HttpClient;
    private baseUrl: string;

    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {

        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : BASE_LOCALHOST_5000;
        console.log('BidPriceInfluencesClient this.baseUrl ', this.baseUrl)

    }

    /**
     * @param masterKey LegSchedule master key
     * @return Successful get
     */
    get(masterKey: number): Observable<LegBidPriceInfluences[]> {
        let url_ = this.baseUrl + "/BidPriceInfluences/{masterKey}";
        if (masterKey === undefined || masterKey === null)
            throw new Error("The parameter 'masterKey' must be defined.");
        url_ = url_.replace("{masterKey}", encodeURIComponent("" + masterKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LegBidPriceInfluences[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LegBidPriceInfluences[]>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<LegBidPriceInfluences[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(LegBidPriceInfluences.fromJS(item));
                }
                else {
                    result200 = <any>null;
                }
                return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("Invalid masterKey", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return null;
        // return _observableOf<LegBidPriceInfluences[]>(null as any);
    }

    /**
     * @param masterKey LegSchedule master key
     * @return Success
     */
    post(masterKey: number, bpInfluences: LegBidPriceInfluences[]): Observable<void> {
        let url_ = this.baseUrl + "/BidPriceInfluences/{masterKey}";
        if (masterKey === undefined || masterKey === null)
            throw new Error("The parameter 'masterKey' must be defined.");
        url_ = url_.replace("{masterKey}", encodeURIComponent("" + masterKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bpInfluences);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("Invalid masterKey", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("Invalid data", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class BidPriceInfluenceThresholdsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : BASE_LOCALHOST_5000;
    }

    /**
     * @param masterKey LegSchedule master key
     * @return Success
     */
    get(masterKey: number): Observable<CabinBidPriceInfluenceThresholds> {
        let url_ = this.baseUrl + "/BidPriceInfluenceThresholds/{masterKey}";
        if (masterKey === undefined || masterKey === null)
            throw new Error("The parameter 'masterKey' must be defined.");
        url_ = url_.replace("{masterKey}", encodeURIComponent("" + masterKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CabinBidPriceInfluenceThresholds>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CabinBidPriceInfluenceThresholds>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CabinBidPriceInfluenceThresholds> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = CabinBidPriceInfluenceThresholds.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("Invalid masterKey", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CabinBidPriceInfluenceThresholds>(null as any);
    }

    /**
     * @param masterKey LegSchedule master key
     * @return Success
     */
    post(masterKey: number, cbpInfluences: CabinBidPriceInfluenceThresholds[]): Observable<void> {
        let url_ = this.baseUrl + "/BidPriceInfluenceThresholds/{masterKey}";
        if (masterKey === undefined || masterKey === null)
            throw new Error("The parameter 'masterKey' must be defined.");
        url_ = url_.replace("{masterKey}", encodeURIComponent("" + masterKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(cbpInfluences);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("Invalid masterKey", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("Invalid data", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}


export interface IFlightClient {
    /**
     * GetByMasterKey description here
     * @param masterKey LegSchedule MasterKey
     * @return Sucessful get
     */
    getByMasterKey(masterKey: number): Observable<FlightDetails>;
    /**
     * @param masterKey LegSchedule master key
     * @param bpInfluences (optional) 
     * @param sUserID (optional) 
     * @return Success
     */
    post(masterKey: number, bpInfluences?: LegBidPriceInfluences[] | null | undefined, sUserID?: string | null | undefined): Observable<void>;
}

@Injectable()
export class FlightClient implements IFlightClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : BASE_LOCALHOST_5000;
        console.log('FlightClient this.baseUrl ', this.baseUrl)
    }

    /**
     * GetByMasterKey description here
     * @param masterKey LegSchedule MasterKey
     * @return Sucessful get
     */
    getByMasterKey(masterKey: number): Observable<FlightDetails> {
        let url_ = this.baseUrl + "/Flight/{masterKey}";
        if (masterKey === undefined || masterKey === null)
            throw new Error("The parameter 'masterKey' must be defined.");
        url_ = url_.replace("{masterKey}", encodeURIComponent("" + masterKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetByMasterKey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByMasterKey(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FlightDetails>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FlightDetails>;
        }));
    }

    protected processGetByMasterKey(response: HttpResponseBase): Observable<FlightDetails> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("Invalid masterKey", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = FlightDetails.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FlightDetails>(null as any);
    }

    /**
     * @param masterKey LegSchedule master key
     * @param bpInfluences (optional) 
     * @param sUserID (optional) 
     * @return Success
     */
    post(masterKey: number, bpInfluences?: LegBidPriceInfluences[] | null | undefined, sUserID?: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/Flight/{masterKey}?";
        if (masterKey === undefined || masterKey === null)
            throw new Error("The parameter 'masterKey' must be defined.");
        url_ = url_.replace("{masterKey}", encodeURIComponent("" + masterKey));
        if (sUserID !== undefined && sUserID !== null)
            url_ += "sUserID=" + encodeURIComponent("" + sUserID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bpInfluences);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("Invalid masterKey", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("Invalid data", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

// @Injectable()
// export class FlightClient {
//     private http: HttpClient;
//     private baseUrl: string;
//     protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

//     constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
//         this.http = http;
//         this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : BASE_LOCALHOST_5000;
//         console.log('FlightClient this.baseUrl ', this.baseUrl)
//     }

//     /**
//      * GetByMasterKey description here
//      * @param masterKey LegSchedule MasterKey
//      * @return Sucessful get
//      */
//     getByMasterKey(masterKey: number): Observable<FlightDetails> {
//         let url_ = this.baseUrl + "/Flight/{masterKey}";
//         if (masterKey === undefined || masterKey === null)
//             throw new Error("The parameter 'masterKey' must be defined.");
//         url_ = url_.replace("{masterKey}", encodeURIComponent("" + masterKey));
//         url_ = url_.replace(/[?&]$/, "");

//         let options_: any = {
//             observe: "response",
//             responseType: "blob",
//             headers: new HttpHeaders({
//                 "Accept": "application/json"
//             })
//         };

//         return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
//             return this.processGetByMasterKey(response_);
//         })).pipe(_observableCatch((response_: any) => {
//             if (response_ instanceof HttpResponseBase) {
//                 try {
//                     return this.processGetByMasterKey(response_ as any);
//                 } catch (e) {
//                     return _observableThrow(e) as any as Observable<FlightDetails>;
//                 }
//             } else
//                 return _observableThrow(response_) as any as Observable<FlightDetails>;
//         }));
//     }

//     protected processGetByMasterKey(response: HttpResponseBase): Observable<FlightDetails> {
//         const status = response.status;
//         const responseBlob =
//             response instanceof HttpResponse ? response.body :
//                 (response as any).error instanceof Blob ? (response as any).error : undefined;

//         let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
//         if (status === 404) {
//             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
//                 return throwException("Invalid masterKey", status, _responseText, _headers);
//             }));
//         } else if (status === 200) {
//             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
//                 let result200: any = null;
//                 let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
//                 result200 = FlightDetails.fromJS(resultData200);
//                 return _observableOf(result200);
//             }));
//         } else if (status !== 200 && status !== 204) {
//             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
//                 return throwException("An unexpected server error occurred.", status, _responseText, _headers);
//             }));
//         }
//         return _observableOf<FlightDetails>(null as any);
//     }

//     /**
//      * @param masterKey LegSchedule master key
//      * @return Success
//      */
//     post(masterKey: number, bpInfluences: LegBidPriceInfluences[]): Observable<void> {
//         let url_ = this.baseUrl + "/Flight/{masterKey}";
//         if (masterKey === undefined || masterKey === null)
//             throw new Error("The parameter 'masterKey' must be defined.");
//         url_ = url_.replace("{masterKey}", encodeURIComponent("" + masterKey));
//         url_ = url_.replace(/[?&]$/, "");

//         const content_ = JSON.stringify(bpInfluences);

//         let options_: any = {
//             body: content_,
//             observe: "response",
//             responseType: "blob",
//             headers: new HttpHeaders({
//                 "Content-Type": "application/json",
//             })
//         };

//         return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
//             return this.processPost(response_);
//         })).pipe(_observableCatch((response_: any) => {
//             if (response_ instanceof HttpResponseBase) {
//                 try {
//                     return this.processPost(response_ as any);
//                 } catch (e) {
//                     return _observableThrow(e) as any as Observable<void>;
//                 }
//             } else
//                 return _observableThrow(response_) as any as Observable<void>;
//         }));
//     }

//     protected processPost(response: HttpResponseBase): Observable<void> {
//         const status = response.status;
//         const responseBlob =
//             response instanceof HttpResponse ? response.body :
//                 (response as any).error instanceof Blob ? (response as any).error : undefined;

//         let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
//         if (status === 200) {
//             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
//                 return _observableOf<void>(null as any);
//             }));
//         } else if (status === 404) {
//             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
//                 return throwException("Invalid masterKey", status, _responseText, _headers);
//             }));
//         } else if (status === 405) {
//             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
//                 return throwException("Invalid data", status, _responseText, _headers);
//             }));
//         } else if (status !== 200 && status !== 204) {
//             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
//                 return throwException("An unexpected server error occurred.", status, _responseText, _headers);
//             }));
//         }
//         return _observableOf<void>(null as any);
//     }
// }


@Injectable()
export class LegFlightDetailsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : BASE_LOCALHOST_5000;
    }

    /**
     * GetByMasterKey description here
     * @param masterKey LegSchedule MasterKey
     * @return Sucessful get
     */
    getByMasterKey(masterKey: number): Observable<LegFlightDetails> {
        let url_ = this.baseUrl + "/LegFlightDetails/{masterKey}";
        if (masterKey === undefined || masterKey === null)
            throw new Error("The parameter 'masterKey' must be defined.");
        url_ = url_.replace("{masterKey}", encodeURIComponent("" + masterKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetByMasterKey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByMasterKey(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LegFlightDetails>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LegFlightDetails>;
        }));
    }

    protected processGetByMasterKey(response: HttpResponseBase): Observable<LegFlightDetails> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("Invalid masterKey", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = LegFlightDetails.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LegFlightDetails>(null as any);
    }
}

export class LoginResponse implements ILoginResponse {
    userName?: string | undefined;
    bearerToken?: string | undefined;

    constructor(data?: ILoginResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.bearerToken = _data["bearerToken"];
        }
    }

    static fromJS(data: any): LoginResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LoginResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["bearerToken"] = this.bearerToken;
        return data;
    }
}

export interface ILoginResponse {
    userName?: string | undefined;
    bearerToken?: string | undefined;
}

export class Login implements ILogin {
    userName?: string | undefined;
    password?: string | undefined;

    constructor(data?: ILogin) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): Login {
        data = typeof data === 'object' ? data : {};
        let result = new Login();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data;
    }
}

export interface ILogin {
    userName?: string | undefined;
    password?: string | undefined;
}

export class AirlineConfig implements IAirlineConfig {
    airlineName?: string | undefined;
    airlineCode?: string | undefined;
    pointsOfSale?: string[] | undefined;
    captureDate?: Date;
    currencyPreference?: string | undefined;
    cabinConfigs?: CabinConfig[] | undefined;
    cabinClassAssignment?: string | undefined;

    constructor(data?: IAirlineConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.airlineName = _data["airlineName"];
            this.airlineCode = _data["airlineCode"];
            if (Array.isArray(_data["pointsOfSale"])) {
                this.pointsOfSale = [] as any;
                for (let item of _data["pointsOfSale"])
                    this.pointsOfSale!.push(item);
            }
            this.captureDate = _data["captureDate"] ? new Date(_data["captureDate"].toString()) : <any>undefined;
            this.currencyPreference = _data["currencyPreference"];
            if (Array.isArray(_data["cabinConfigs"])) {
                this.cabinConfigs = [] as any;
                for (let item of _data["cabinConfigs"])
                    this.cabinConfigs!.push(CabinConfig.fromJS(item));
            }
            this.cabinClassAssignment = _data["cabinClassAssignment"];
        }
    }

    static fromJS(data: any): AirlineConfig {
        data = typeof data === 'object' ? data : {};
        let result = new AirlineConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["airlineName"] = this.airlineName;
        data["airlineCode"] = this.airlineCode;
        if (Array.isArray(this.pointsOfSale)) {
            data["pointsOfSale"] = [];
            for (let item of this.pointsOfSale)
                data["pointsOfSale"].push(item);
        }
        data["captureDate"] = this.captureDate ? this.captureDate.toISOString() : <any>undefined;
        data["currencyPreference"] = this.currencyPreference;
        if (Array.isArray(this.cabinConfigs)) {
            data["cabinConfigs"] = [];
            for (let item of this.cabinConfigs)
                data["cabinConfigs"].push(item.toJSON());
        }
        data["cabinClassAssignment"] = this.cabinClassAssignment;
        return data;
    }
}

export interface IAirlineConfig {
    airlineName?: string | undefined;
    airlineCode?: string | undefined;
    pointsOfSale?: string[] | undefined;
    captureDate?: Date;
    currencyPreference?: string | undefined;
    cabinConfigs?: CabinConfig[] | undefined;
    cabinClassAssignment?: string | undefined;
}

export class CabinConfig implements ICabinConfig {
    cabinName!: string;
    bucketConfigs?: BucketConfig[] | undefined;

    constructor(data?: ICabinConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cabinName = _data["cabinName"];
            if (Array.isArray(_data["bucketConfigs"])) {
                this.bucketConfigs = [] as any;
                for (let item of _data["bucketConfigs"])
                    this.bucketConfigs!.push(BucketConfig.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CabinConfig {
        data = typeof data === 'object' ? data : {};
        let result = new CabinConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cabinName"] = this.cabinName;
        if (Array.isArray(this.bucketConfigs)) {
            data["bucketConfigs"] = [];
            for (let item of this.bucketConfigs)
                data["bucketConfigs"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICabinConfig {
    cabinName: string;
    bucketConfigs?: BucketConfig[] | undefined;
}

export class BucketConfig implements IBucketConfig {
    bucketOrder?: number;
    bucketLetter?: string | undefined;
    fare?: number;
    /** Specify color in '#rrggbb' format. */
    colorPreference?: string | undefined;

    constructor(data?: IBucketConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bucketOrder = _data["bucketOrder"];
            this.bucketLetter = _data["bucketLetter"];
            this.fare = _data["fare"];
            this.colorPreference = _data["colorPreference"];
        }
    }

    static fromJS(data: any): BucketConfig {
        data = typeof data === 'object' ? data : {};
        let result = new BucketConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bucketOrder"] = this.bucketOrder;
        data["bucketLetter"] = this.bucketLetter;
        data["fare"] = this.fare;
        data["colorPreference"] = this.colorPreference;
        return data;
    }
}

export interface IBucketConfig {
    bucketOrder?: number;
    bucketLetter?: string | undefined;
    fare?: number;
    /** Specify color in '#rrggbb' format. */
    colorPreference?: string | undefined;
}

export class LegBidPriceInfluences implements ILegBidPriceInfluences {
    legMasterKey!: number;
    cabinLetter!: string;
    min?: number | undefined;
    max?: number | undefined;
    mult?: number | undefined;
    addSub?: number | undefined;
    partialMin!: string;
    partialMax!: string;
    maxSeats?: number | undefined;

    constructor(data?: ILegBidPriceInfluences) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.legMasterKey = _data["legMasterKey"];
            this.cabinLetter = _data["cabinLetter"];
            this.min = _data["min"];
            this.max = _data["max"];
            this.mult = _data["mult"];
            this.addSub = _data["addSub"];
            this.partialMin = _data["partialMin"];
            this.partialMax = _data["partialMax"];
            this.maxSeats = _data["maxSeats"];
        }
    }

    static fromJS(data: any): LegBidPriceInfluences {
        data = typeof data === 'object' ? data : {};
        let result = new LegBidPriceInfluences();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["legMasterKey"] = this.legMasterKey;
        data["cabinLetter"] = this.cabinLetter;
        data["min"] = this.min;
        data["max"] = this.max;
        data["mult"] = this.mult;
        data["addSub"] = this.addSub;
        data["partialMin"] = this.partialMin;
        data["partialMax"] = this.partialMax;
        data["maxSeats"] = this.maxSeats;
        return data;
    }
}

export interface ILegBidPriceInfluences {
    legMasterKey: number;
    cabinLetter: string;
    min?: number | undefined;
    max?: number | undefined;
    mult?: number | undefined;
    addSub?: number | undefined;
    partialMin: string;
    partialMax: string;
    maxSeats?: number | undefined;
}

export class CabinBidPriceInfluenceThresholds implements ICabinBidPriceInfluenceThresholds {
    pointOfSale!: string;
    cabinLetter!: string;
    minimumThresholds?: BidPriceInfluenceThresholds | undefined;
    maximumThresholds?: BidPriceInfluenceThresholds | undefined;

    constructor(data?: ICabinBidPriceInfluenceThresholds) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pointOfSale = _data["pointOfSale"];
            this.cabinLetter = _data["cabinLetter"];
            this.minimumThresholds = _data["minimumThresholds"] ? BidPriceInfluenceThresholds.fromJS(_data["minimumThresholds"]) : <any>undefined;
            this.maximumThresholds = _data["maximumThresholds"] ? BidPriceInfluenceThresholds.fromJS(_data["maximumThresholds"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CabinBidPriceInfluenceThresholds {
        data = typeof data === 'object' ? data : {};
        let result = new CabinBidPriceInfluenceThresholds();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pointOfSale"] = this.pointOfSale;
        data["cabinLetter"] = this.cabinLetter;
        data["minimumThresholds"] = this.minimumThresholds ? this.minimumThresholds.toJSON() : <any>undefined;
        data["maximumThresholds"] = this.maximumThresholds ? this.maximumThresholds.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICabinBidPriceInfluenceThresholds {
    pointOfSale: string;
    cabinLetter: string;
    minimumThresholds?: BidPriceInfluenceThresholds | undefined;
    maximumThresholds?: BidPriceInfluenceThresholds | undefined;
}

export class BidPriceInfluenceThresholds implements IBidPriceInfluenceThresholds {
    /** Whether or not to use these thresholds */
    usingThresholds!: boolean;
    bezierPoints?: BidPriceInfluenceThresholdBezierPoint[] | undefined;
    fares?: number[] | undefined;

    constructor(data?: IBidPriceInfluenceThresholds) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.usingThresholds = _data["usingThresholds"];
            if (Array.isArray(_data["bezierPoints"])) {
                this.bezierPoints = [] as any;
                for (let item of _data["bezierPoints"])
                    this.bezierPoints!.push(BidPriceInfluenceThresholdBezierPoint.fromJS(item));
            }
            if (Array.isArray(_data["fares"])) {
                this.fares = [] as any;
                for (let item of _data["fares"])
                    this.fares!.push(item);
            }
        }
    }

    static fromJS(data: any): BidPriceInfluenceThresholds {
        data = typeof data === 'object' ? data : {};
        let result = new BidPriceInfluenceThresholds();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["usingThresholds"] = this.usingThresholds;
        if (Array.isArray(this.bezierPoints)) {
            data["bezierPoints"] = [];
            for (let item of this.bezierPoints)
                data["bezierPoints"].push(item.toJSON());
        }
        if (Array.isArray(this.fares)) {
            data["fares"] = [];
            for (let item of this.fares)
                data["fares"].push(item);
        }
        return data;
    }
}

export interface IBidPriceInfluenceThresholds {
    /** Whether or not to use these thresholds */
    usingThresholds: boolean;
    bezierPoints?: BidPriceInfluenceThresholdBezierPoint[] | undefined;
    fares?: number[] | undefined;
}

export class BidPriceInfluenceThresholdBezierPoint implements IBidPriceInfluenceThresholdBezierPoint {
    /** X axis on graph */
    ndo!: number;
    /** Y axis on graph */
    fare!: number;

    constructor(data?: IBidPriceInfluenceThresholdBezierPoint) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ndo = _data["ndo"];
            this.fare = _data["fare"];
        }
    }

    static fromJS(data: any): BidPriceInfluenceThresholdBezierPoint {
        data = typeof data === 'object' ? data : {};
        let result = new BidPriceInfluenceThresholdBezierPoint();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ndo"] = this.ndo;
        data["fare"] = this.fare;
        return data;
    }
}

export interface IBidPriceInfluenceThresholdBezierPoint {
    /** X axis on graph */
    ndo: number;
    /** Y axis on graph */
    fare: number;
}


export class FlightDetails implements IFlightDetails {
    masterKey!: number;
    prevYearMasterKey?: number | undefined;
    airlineCode?: string | undefined;
    origin?: string | undefined;
    destination?: string | undefined;
    equipment?: string | undefined;
    flightNumber?: number;
    departureDateTime?: Date;
    arrivalDateTime?: Date;
    lid?: number;
    capacity?: number;
    cabinDetails?: CabinDetails[] | undefined;
    bookings?: string[] | undefined;

    constructor(data?: IFlightDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.masterKey = _data["masterKey"];
            this.prevYearMasterKey = _data["prevYearMasterKey"];
            this.airlineCode = _data["airlineCode"];
            this.origin = _data["origin"];
            this.destination = _data["destination"];
            this.equipment = _data["equipment"];
            this.flightNumber = _data["flightNumber"];
            this.departureDateTime = _data["departureDateTime"] ? new Date(_data["departureDateTime"].toString()) : <any>undefined;
            this.arrivalDateTime = _data["arrivalDateTime"] ? new Date(_data["arrivalDateTime"].toString()) : <any>undefined;
            this.lid = _data["lid"];
            this.capacity = _data["capacity"];
            if (Array.isArray(_data["cabinDetails"])) {
                this.cabinDetails = [] as any;
                for (let item of _data["cabinDetails"])
                    this.cabinDetails!.push(CabinDetails.fromJS(item));
            }
            if (Array.isArray(_data["bookings"])) {
                this.bookings = [] as any;
                for (let item of _data["bookings"])
                    this.bookings!.push(item);
            }
        }
    }

    static fromJS(data: any): FlightDetails {
        data = typeof data === 'object' ? data : {};
        let result = new FlightDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["masterKey"] = this.masterKey;
        data["prevYearMasterKey"] = this.prevYearMasterKey;
        data["airlineCode"] = this.airlineCode;
        data["origin"] = this.origin;
        data["destination"] = this.destination;
        data["equipment"] = this.equipment;
        data["flightNumber"] = this.flightNumber;
        data["departureDateTime"] = this.departureDateTime ? this.departureDateTime.toISOString() : <any>undefined;
        data["arrivalDateTime"] = this.arrivalDateTime ? this.arrivalDateTime.toISOString() : <any>undefined;
        data["lid"] = this.lid;
        data["capacity"] = this.capacity;
        if (Array.isArray(this.cabinDetails)) {
            data["cabinDetails"] = [];
            for (let item of this.cabinDetails)
                data["cabinDetails"].push(item.toJSON());
        }
        if (Array.isArray(this.bookings)) {
            data["bookings"] = [];
            for (let item of this.bookings)
                data["bookings"].push(item);
        }
        return data;
    }
}

export interface IFlightDetails {
    masterKey: number;
    prevYearMasterKey?: number | undefined;
    airlineCode?: string | undefined;
    origin?: string | undefined;
    destination?: string | undefined;
    equipment?: string | undefined;
    flightNumber?: number;
    departureDateTime?: Date;
    arrivalDateTime?: Date;
    lid?: number;
    capacity?: number;
    cabinDetails?: CabinDetails[] | undefined;
    bookings?: string[] | undefined;
}

export class CabinDetails implements ICabinDetails {
    cabinLetter?: string | undefined;
    cabinName?: string | undefined;
    lid?: number;
    capacity?: number;
    originalBidPrices?: number[] | undefined;
    adjustedBidPrices?: number[] | undefined;
    bucketConfigs?: FlightBucketConfig[] | undefined;
    bookings?: number;

    constructor(data?: ICabinDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cabinLetter = _data["cabinLetter"];
            this.cabinName = _data["cabinName"];
            this.lid = _data["lid"];
            this.capacity = _data["capacity"];
            if (Array.isArray(_data["originalBidPrices"])) {
                this.originalBidPrices = [] as any;
                for (let item of _data["originalBidPrices"])
                    this.originalBidPrices!.push(item);
            }
            if (Array.isArray(_data["adjustedBidPrices"])) {
                this.adjustedBidPrices = [] as any;
                for (let item of _data["adjustedBidPrices"])
                    this.adjustedBidPrices!.push(item);
            }
            if (Array.isArray(_data["bucketConfigs"])) {
                this.bucketConfigs = [] as any;
                for (let item of _data["bucketConfigs"])
                    this.bucketConfigs!.push(FlightBucketConfig.fromJS(item));
            }
            this.bookings = _data["bookings"];
        }
    }

    static fromJS(data: any): CabinDetails {
        data = typeof data === 'object' ? data : {};
        let result = new CabinDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cabinLetter"] = this.cabinLetter;
        data["cabinName"] = this.cabinName;
        data["lid"] = this.lid;
        data["capacity"] = this.capacity;
        if (Array.isArray(this.originalBidPrices)) {
            data["originalBidPrices"] = [];
            for (let item of this.originalBidPrices)
                data["originalBidPrices"].push(item);
        }
        if (Array.isArray(this.adjustedBidPrices)) {
            data["adjustedBidPrices"] = [];
            for (let item of this.adjustedBidPrices)
                data["adjustedBidPrices"].push(item);
        }
        if (Array.isArray(this.bucketConfigs)) {
            data["bucketConfigs"] = [];
            for (let item of this.bucketConfigs)
                data["bucketConfigs"].push(item.toJSON());
        }
        data["bookings"] = this.bookings;
        return data;
    }
}

export interface ICabinDetails {
    cabinLetter?: string | undefined;
    cabinName?: string | undefined;
    lid?: number;
    capacity?: number;
    originalBidPrices?: number[] | undefined;
    adjustedBidPrices?: number[] | undefined;
    bucketConfigs?: FlightBucketConfig[] | undefined;
    bookings?: number;
}

export class FlightBucketConfig implements IFlightBucketConfig {
    bucketOrder?: number;
    bucketLetter?: string | undefined;
    fare?: number;
    esAdjustedFare?: number | undefined;
    esSa?: number | undefined;
    esPos?: string | undefined;
    oeAdjustedFare?: number | undefined;
    oeSa?: number | undefined;
    oePos?: string | undefined;
    /** Specify color in '#rrggbb' format. */
    colorPreference?: string | undefined;
    bookings?: number;
    esAu?: number | undefined;
    oeAu?: number | undefined;

    constructor(data?: IFlightBucketConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bucketOrder = _data["bucketOrder"];
            this.bucketLetter = _data["bucketLetter"];
            this.fare = _data["fare"];
            this.esAdjustedFare = _data["esAdjustedFare"];
            this.esSa = _data["esSa"];
            this.esPos = _data["esPos"];
            this.oeAdjustedFare = _data["oeAdjustedFare"];
            this.oeSa = _data["oeSa"];
            this.oePos = _data["oePos"];
            this.colorPreference = _data["colorPreference"];
            this.bookings = _data["bookings"];
            this.esAu = _data["esAu"];
            this.oeAu = _data["oeAu"];
        }
    }

    static fromJS(data: any): FlightBucketConfig {
        data = typeof data === 'object' ? data : {};
        let result = new FlightBucketConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bucketOrder"] = this.bucketOrder;
        data["bucketLetter"] = this.bucketLetter;
        data["fare"] = this.fare;
        data["esAdjustedFare"] = this.esAdjustedFare;
        data["esSa"] = this.esSa;
        data["esPos"] = this.esPos;
        data["oeAdjustedFare"] = this.oeAdjustedFare;
        data["oeSa"] = this.oeSa;
        data["oePos"] = this.oePos;
        data["colorPreference"] = this.colorPreference;
        data["bookings"] = this.bookings;
        data["esAu"] = this.esAu;
        data["oeAu"] = this.oeAu;
        return data;
    }
}

export interface IFlightBucketConfig {
    bucketOrder?: number;
    bucketLetter?: string | undefined;
    fare?: number;
    esAdjustedFare?: number | undefined;
    esSa?: number | undefined;
    esPos?: string | undefined;
    oeAdjustedFare?: number | undefined;
    oeSa?: number | undefined;
    oePos?: string | undefined;
    /** Specify color in '#rrggbb' format. */
    colorPreference?: string | undefined;
    bookings?: number;
    esAu?: number | undefined;
    oeAu?: number | undefined;
}

export class CabinBidPriceValues implements ICabinBidPriceValues {
    legMasterKey!: number;
    cabinLetter!: string;
    currentBidPrices?: (number | undefined)[] | undefined;
    bidPriceMethod!: BidPriceMethod;

    constructor(data?: ICabinBidPriceValues) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.legMasterKey = _data["legMasterKey"];
            this.cabinLetter = _data["cabinLetter"];
            if (Array.isArray(_data["currentBidPrices"])) {
                this.currentBidPrices = [] as any;
                for (let item of _data["currentBidPrices"])
                    this.currentBidPrices!.push(item);
            }
            this.bidPriceMethod = _data["bidPriceMethod"];
        }
    }

    static fromJS(data: any): CabinBidPriceValues {
        data = typeof data === 'object' ? data : {};
        let result = new CabinBidPriceValues();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["legMasterKey"] = this.legMasterKey;
        data["cabinLetter"] = this.cabinLetter;
        if (Array.isArray(this.currentBidPrices)) {
            data["currentBidPrices"] = [];
            for (let item of this.currentBidPrices)
                data["currentBidPrices"].push(item);
        }
        data["bidPriceMethod"] = this.bidPriceMethod;
        return data;
    }
}

export interface ICabinBidPriceValues {
    legMasterKey: number;
    cabinLetter: string;
    currentBidPrices?: (number | undefined)[] | undefined;
    bidPriceMethod: BidPriceMethod;
}

export enum BidPriceMethod {
    Original = "original",
    Adjusted = "adjusted",
}

export class LegFlightDetails implements ILegFlightDetails {
    masterKey!: number;
    prevYearMasterKey?: number | undefined;
    airlineCode?: string;
    origin?: string;
    destination?: string;
    equipment?: string | undefined;
    flightNumber?: number;
    departureDateTime?: Date;
    arrivalDateTime?: Date;
    lid?: number;
    capacity?: number;
    cabinDetails?: LegCabinDetails[] | undefined;
    bookings?: string | undefined;

    constructor(data?: ILegFlightDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.masterKey = _data["masterKey"];
            this.prevYearMasterKey = _data["prevYearMasterKey"];
            this.airlineCode = _data["airlineCode"];
            this.origin = _data["origin"];
            this.destination = _data["destination"];
            this.equipment = _data["equipment"];
            this.flightNumber = _data["flightNumber"];
            this.departureDateTime = _data["departureDateTime"] ? new Date(_data["departureDateTime"].toString()) : <any>undefined;
            this.arrivalDateTime = _data["arrivalDateTime"] ? new Date(_data["arrivalDateTime"].toString()) : <any>undefined;
            this.lid = _data["lid"];
            this.capacity = _data["capacity"];
            if (Array.isArray(_data["cabinDetails"])) {
                this.cabinDetails = [] as any;
                for (let item of _data["cabinDetails"])
                    this.cabinDetails!.push(LegCabinDetails.fromJS(item));
            }
            this.bookings = _data["bookings"];
        }
    }

    static fromJS(data: any): LegFlightDetails {
        data = typeof data === 'object' ? data : {};
        let result = new LegFlightDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["masterKey"] = this.masterKey;
        data["prevYearMasterKey"] = this.prevYearMasterKey;
        data["airlineCode"] = this.airlineCode;
        data["origin"] = this.origin;
        data["destination"] = this.destination;
        data["equipment"] = this.equipment;
        data["flightNumber"] = this.flightNumber;
        data["departureDateTime"] = this.departureDateTime ? this.departureDateTime.toISOString() : <any>undefined;
        data["arrivalDateTime"] = this.arrivalDateTime ? this.arrivalDateTime.toISOString() : <any>undefined;
        data["lid"] = this.lid;
        data["capacity"] = this.capacity;
        if (Array.isArray(this.cabinDetails)) {
            data["cabinDetails"] = [];
            for (let item of this.cabinDetails)
                data["cabinDetails"].push(item.toJSON());
        }
        data["bookings"] = this.bookings;
        return data;
    }
}

export interface ILegFlightDetails {
    masterKey: number;
    prevYearMasterKey?: number | undefined;
    airlineCode?: string;
    origin?: string;
    destination?: string;
    equipment?: string | undefined;
    flightNumber?: number;
    departureDateTime?: Date;
    arrivalDateTime?: Date;
    lid?: number;
    capacity?: number;
    cabinDetails?: LegCabinDetails[] | undefined;
    bookings?: string | undefined;
}

export class LegCabinDetails implements ILegCabinDetails {
    cabinLetter?: string | undefined;
    lid?: number;
    capacity?: number;
    originalBidPrices?: number[] | undefined;
    adjustedBidPrices?: number[] | undefined;
    cabinConfigs?: CabinConfig | undefined;

    constructor(data?: ILegCabinDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cabinLetter = _data["cabinLetter"];
            this.lid = _data["lid"];
            this.capacity = _data["capacity"];
            if (Array.isArray(_data["originalBidPrices"])) {
                this.originalBidPrices = [] as any;
                for (let item of _data["originalBidPrices"])
                    this.originalBidPrices!.push(item);
            }
            if (Array.isArray(_data["adjustedBidPrices"])) {
                this.adjustedBidPrices = [] as any;
                for (let item of _data["adjustedBidPrices"])
                    this.adjustedBidPrices!.push(item);
            }
            this.cabinConfigs = _data["cabinConfigs"] ? CabinConfig.fromJS(_data["cabinConfigs"]) : <any>undefined;
        }
    }

    static fromJS(data: any): LegCabinDetails {
        data = typeof data === 'object' ? data : {};
        let result = new LegCabinDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cabinLetter"] = this.cabinLetter;
        data["lid"] = this.lid;
        data["capacity"] = this.capacity;
        if (Array.isArray(this.originalBidPrices)) {
            data["originalBidPrices"] = [];
            for (let item of this.originalBidPrices)
                data["originalBidPrices"].push(item);
        }
        if (Array.isArray(this.adjustedBidPrices)) {
            data["adjustedBidPrices"] = [];
            for (let item of this.adjustedBidPrices)
                data["adjustedBidPrices"].push(item);
        }
        data["cabinConfigs"] = this.cabinConfigs ? this.cabinConfigs.toJSON() : <any>undefined;
        return data;
    }
}

export interface ILegCabinDetails {
    cabinLetter?: string | undefined;
    lid?: number;
    capacity?: number;
    originalBidPrices?: number[] | undefined;
    adjustedBidPrices?: number[] | undefined;
    cabinConfigs?: CabinConfig | undefined;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}